--goal is to use 5 rectangles per well
-- instead of 5 rays
-- these might work better because the rectangles have thickness

CREATE OR REPLACE TABLE
RECTANGLES_TO_OFFSET
AS

WITH INIT_TBL AS (
SELECT 
ID, FTP_X, FTP_Y, LTP_X, LTP_Y
FROM INIT_TBL_0
GROUP BY ID
HAVING ID IS NOT NULL
)

, INIT_TBL_CLEAN AS (
SELECT *
, CASE WHEN LTP_Y > FTP_Y THEN 'TOE UP'
ELSE 'TOE DOWN' END AS TOE_DIRECTION
FROM INIT_TBL
WHERE FTP_X IS NOT NULL
AND FTP_Y IS NOT NULL
AND LTP_X IS NOT NULL
AND LTP_Y IS NOT NULL
)

, ALL_TOE_DOWN AS (
SELECT ID
, CASE WHEN TOE_DIRECTION = 'TOE UP' THEN LTP_X ELSE FTP_X END AS FTP_X
, CASE WHEN TOE_DIRECTION = 'TOE UP' THEN LTP_Y ELSE FTP_Y END AS FTP_Y
, CASE WHEN TOE_DIRECTION = 'TOE UP' THEN FTP_X ELSE LTP_X END AS LTP_X
, CASE WHEN TOE_DIRECTION = 'TOE UP' THEN FTP_Y ELSE LTP_Y END AS LTP_Y
FROM INIT_TBL_CLEAN
)

--fix wells that are perfectly vertical or horizontal
--this is probably not necessary for rectangles logic but is holdover from ray-based method
, PERTURBED_HORIZ_OR_VERT AS (
SELECT ID, FTP_X, FTP_Y
, CASE WHEN LTP_X = FTP_X THEN LTP_X + 0.2 ELSE LTP_X END AS LTP_X
, CASE WHEN LTP_Y = FTP_Y THEN LTP_Y - 0.2 ELSE LTP_Y END AS LTP_Y
FROM ALL_TOE_DOWN
)

, MIN_AND_MAX_XY AS (
SELECT *
, CASE WHEN FTP_X < LTP_X THEN FTP_X ELSE LTP_X END AS MIN_X
, CASE WHEN FTP_Y < LTP_Y THEN FTP_Y ELSE LTP_Y END AS MIN_Y
, CASE WHEN FTP_X > LTP_X THEN FTP_X ELSE LTP_X END AS MAX_X
, CASE WHEN FTP_Y > LTP_Y THEN FTP_Y ELSE LTP_Y END AS MAX_Y
FROM PERTURBED_HORIZ_OR_VERT
)

--course filtering of offset wells
, INIT_NEARBY_WELLS AS (
SELECT TGT.*
, OFFS.ID AS OFFSET_ID
, OFFS.FTP_X AS OFFSET_FTP_X, OFFS.FTP_Y AS OFFSET_FTP_Y
, OFFS.LTP_X AS OFFSET_LTP_X, OFFS.LTP_Y AS OFFSET_LTP_Y
, OFFS.MIN_X AS OFFSET_MIN_X, OFFS.MIN_Y AS OFFSET_MIN_Y
, OFFS.MAX_X AS OFFSET_MAX_X, OFFS.MAX_Y AS OFFSET_MAX_Y
FROM MIN_AND_MAX_XY TGT
CROSS JOIN MIN_AND_MAX_XY OFFS
WHERE OFFS.MAX_X >= TGT.MIN_X - 10000
AND OFFS.MIN_X <= TGT.MAX_X + 10000
AND OFFS.MAX_Y >= TGT.MIN_Y - 10000
AND OFFS.MIN_Y <= TGT.MAX_Y + 10000
AND TGT.ID != OFFS.ID
)

--bring everything down so tgt_min_Y = 0
, LTP_ON_ORIGIN AS (
SELECT ID, OFFSET_ID
, FTP_X - LTP_X AS FTP_X, FTP_Y - MIN_Y AS FTP_Y, LTP_X - LTP_X AS LTP_X, LTP_Y - MIN_Y AS LTP_Y
, MIN_X - LTP_X AS MIN_X, MIN_Y - MIN_Y AS MIN_Y, MAX_X - LTP_X AS MAX_X, MAX_Y - MIN_Y AS MAX_Y
, OFFSET_FTP_X - LTP_X AS OFFSET_FTP_X, OFFSET_FTP_Y - MIN_Y AS OFFSET_FTP_Y 
, OFFSET_LTP_X - LTP_X AS OFFSET_LTP_X, OFFSET_LTP_Y - MIN_Y AS OFFSET_LTP_Y
, OFFSET_MIN_X - LTP_X AS OFFSET_MIN_X, OFFSET_MIN_Y - MIN_Y AS OFFSET_MIN_Y
, OFFSET_MAX_X - LTP_X AS OFFSET_MAX_X, OFFSET_MAX_Y - MIN_Y AS OFFSET_MAX_Y
FROM INIT_NEARBY_WELLS
)

--have to recalculate the min and mx X/Y's cause min_X may not be paired with min_Y
, TGT_ROTATED_TO_VERTICAL AS (
SELECT ID, OFFSET_ID
, ATAN(FTP_X/FTP_Y) AS RAD_TO_ROTATE
, FTP_X * COS(RAD_TO_ROTATE) - FTP_Y * SIN(RAD_TO_ROTATE) AS FTP_X
, FTP_X * SIN(RAD_TO_ROTATE) + FTP_Y * COS(RAD_TO_ROTATE) AS FTP_Y
, LTP_X * COS(RAD_TO_ROTATE) - LTP_Y * SIN(RAD_TO_ROTATE) AS LTP_X
, LTP_X * SIN(RAD_TO_ROTATE) + LTP_Y * COS(RAD_TO_ROTATE) AS LTP_Y
--offset points
, OFFSET_FTP_X * COS(RAD_TO_ROTATE) - OFFSET_FTP_Y * SIN(RAD_TO_ROTATE) AS OFFSET_FTP_X
, OFFSET_FTP_X * SIN(RAD_TO_ROTATE) + OFFSET_FTP_Y * COS(RAD_TO_ROTATE) AS OFFSET_FTP_Y
, OFFSET_LTP_X * COS(RAD_TO_ROTATE) - OFFSET_LTP_Y * SIN(RAD_TO_ROTATE) AS OFFSET_LTP_X
, OFFSET_LTP_X * SIN(RAD_TO_ROTATE) + OFFSET_LTP_Y * COS(RAD_TO_ROTATE) AS OFFSET_LTP_Y
FROM LTP_ON_ORIGIN
)

--Added code from min rectangle v1:
--split target well into 
--tgt well is split into 5 pieces where piece 1 is bottom and piece 5 is top (max Y)
--this gets tricky because minY is no longer 0 for each target segment
, SEGMENTS_5_OF_WELLS_1 AS (
SELECT *, 1 AS TGT_WELL_PIECE
FROM TGT_ROTATED_TO_VERTICAL
UNION ALL
SELECT *, 2 AS TGT_WELL_PIECE
FROM TGT_ROTATED_TO_VERTICAL
UNION ALL
SELECT *, 3 AS TGT_WELL_PIECE
FROM TGT_ROTATED_TO_VERTICAL
UNION ALL
SELECT *, 4 AS TGT_WELL_PIECE
FROM TGT_ROTATED_TO_VERTICAL
UNION ALL
SELECT *, 5 AS TGT_WELL_PIECE
FROM TGT_ROTATED_TO_VERTICAL
)

, SEGMENTS_5_OF_WELLS_2 AS (
SELECT *
, CASE 
WHEN TGT_WELL_PIECE = 1 THEN 0.2 * FTP_Y
WHEN TGT_WELL_PIECE = 2 THEN 0.4 * FTP_Y
WHEN TGT_WELL_PIECE = 3 THEN 0.6 * FTP_Y
WHEN TGT_WELL_PIECE = 4 THEN 0.8 * FTP_Y
WHEN TGT_WELL_PIECE = 5 THEN 1.0 * FTP_Y
ELSE NULL END AS FTP_Y_SEGMENT

, CASE 
WHEN TGT_WELL_PIECE = 1 THEN 0.0 * FTP_Y
WHEN TGT_WELL_PIECE = 2 THEN 0.2 * FTP_Y
WHEN TGT_WELL_PIECE = 3 THEN 0.4 * FTP_Y
WHEN TGT_WELL_PIECE = 4 THEN 0.6 * FTP_Y
WHEN TGT_WELL_PIECE = 5 THEN 0.8 * FTP_Y
ELSE NULL END AS LTP_Y_SEGMENT
FROM SEGMENTS_5_OF_WELLS_1
)

, SEGMENTS_5_OF_WELLS_3 AS (
SELECT ID, TGT_WELL_PIECE, OFFSET_ID, RAD_TO_ROTATE, FTP_X, 
FTP_Y_SEGMENT AS FTP_Y, LTP_X, LTP_Y_SEGMENT AS LTP_Y,
OFFSET_FTP_X, OFFSET_FTP_Y, OFFSET_LTP_X, OFFSET_LTP_Y, 
FROM SEGMENTS_5_OF_WELLS_2
)

, ROTATED_WITH_MIN_MAX_XY AS (
SELECT *
, CASE WHEN FTP_X < LTP_X THEN FTP_X ELSE LTP_X END AS MIN_X --don't really need min & max X's
, CASE WHEN FTP_Y < LTP_Y THEN FTP_Y ELSE LTP_Y END AS MIN_Y
, CASE WHEN FTP_X > LTP_X THEN FTP_X ELSE LTP_X END AS MAX_X --min/max X should = 0
, CASE WHEN FTP_Y > LTP_Y THEN FTP_Y ELSE LTP_Y END AS MAX_Y
--offsets
, CASE WHEN OFFSET_FTP_X < OFFSET_LTP_X THEN OFFSET_FTP_X ELSE OFFSET_LTP_X END AS OFFSET_MIN_X
, CASE WHEN OFFSET_FTP_Y < OFFSET_LTP_Y THEN OFFSET_FTP_Y ELSE OFFSET_LTP_Y END AS OFFSET_MIN_Y
, CASE WHEN OFFSET_FTP_X > OFFSET_LTP_X THEN OFFSET_FTP_X ELSE OFFSET_LTP_X END AS OFFSET_MAX_X
, CASE WHEN OFFSET_FTP_Y > OFFSET_LTP_Y THEN OFFSET_FTP_Y ELSE OFFSET_LTP_Y END AS OFFSET_MAX_Y
FROM SEGMENTS_5_OF_WELLS_3
)

, OFFSET_WELL_HAS_OVERLAP_1 AS (
SELECT *
FROM ROTATED_WITH_MIN_MAX_XY
WHERE NOT (OFFSET_MIN_Y > MAX_Y)
)

, OFFSET_WELL_HAS_OVERLAP_2 AS (
SELECT * EXCLUDE (OFFSET_MIN_X, OFFSET_MIN_Y, OFFSET_MAX_X, OFFSET_MAX_Y)
FROM OFFSET_WELL_HAS_OVERLAP_1
WHERE NOT (OFFSET_MAX_Y < MIN_Y)
)

--clip the offset well end points as necessary
--if part of an offset is above/below min/max Y of tgt well, remove those extra portions of offset stick
, CLIPPED_OFFSET_WELLS AS (
SELECT ID, OFFSET_ID, RAD_TO_ROTATE, FTP_X, FTP_Y, LTP_X, LTP_Y, TGT_WELL_PIECE
--work the ftp point, clip if it's below min or above max Y
, CASE
  WHEN OFFSET_FTP_Y < MIN_Y THEN OFFSET_FTP_X + (MIN_Y - OFFSET_FTP_Y) / (OFFSET_LTP_Y - OFFSET_FTP_Y) * (OFFSET_LTP_X - OFFSET_FTP_X) --solve y=mx+b for x given y = MIN_Y
  WHEN OFFSET_FTP_Y > MAX_Y THEN OFFSET_FTP_X + (MAX_Y - OFFSET_FTP_Y) / (OFFSET_LTP_Y - OFFSET_FTP_Y) * (OFFSET_LTP_X - OFFSET_FTP_X)
  ELSE OFFSET_FTP_X END AS OFFSET_FTP_X 
, CASE 
  WHEN OFFSET_FTP_Y < MIN_Y THEN MIN_Y 
  WHEN OFFSET_FTP_Y > MAX_Y THEN MAX_Y  
  ELSE OFFSET_FTP_Y END AS OFFSET_FTP_Y
--work the ltp
--expression is the same cause segment intersects same y_max or y_min whether coming from ltp or ftp
, CASE
  WHEN OFFSET_LTP_Y < MIN_Y THEN OFFSET_FTP_X + (MIN_Y - OFFSET_FTP_Y) / (OFFSET_LTP_Y - OFFSET_FTP_Y) * (OFFSET_LTP_X - OFFSET_FTP_X)
  WHEN OFFSET_LTP_Y > MAX_Y THEN OFFSET_FTP_X + (MAX_Y - OFFSET_FTP_Y) / (OFFSET_LTP_Y - OFFSET_FTP_Y) * (OFFSET_LTP_X - OFFSET_FTP_X)
  ELSE OFFSET_LTP_X END AS OFFSET_LTP_X 
, CASE 
  WHEN OFFSET_LTP_Y < MIN_Y THEN MIN_Y 
  WHEN OFFSET_LTP_Y > MAX_Y THEN MAX_Y  
  ELSE OFFSET_LTP_Y END AS OFFSET_LTP_Y
FROM OFFSET_WELL_HAS_OVERLAP_2
)

--given that the target well is on the Y axis from origin up to positive Y value of well's lateral length,
--we know length of box out to offset well is simply the OFFSET_MIN_X, when offset well is in positive X direction of target well
--or OFFSET_MAX_X when offset well is in negative X direction of target well (west of target well)
, BOX_LENGTH AS (
SELECT *
, CASE WHEN OFFSET_FTP_X < OFFSET_LTP_X THEN OFFSET_FTP_X ELSE OFFSET_LTP_X END AS OFFSET_MIN_X
, CASE WHEN OFFSET_FTP_X > OFFSET_LTP_X THEN OFFSET_FTP_X ELSE OFFSET_LTP_X END AS OFFSET_MAX_X
, CASE
  WHEN OFFSET_MIN_X < 0 AND OFFSET_MAX_X > 0 THEN 0
  WHEN ABS(OFFSET_MIN_X) < 0.01 THEN 0
  WHEN ABS(OFFSET_MAX_X) < 0.01 THEN 0
  WHEN OFFSET_MIN_X > 0 THEN OFFSET_MIN_X
  WHEN OFFSET_MAX_X < 0 THEN -1 * OFFSET_MAX_X
  ELSE NULL END AS BOX_LENGTH
, CASE
WHEN OFFSET_MIN_X < 0 AND OFFSET_MAX_X > 0 THEN 'INTERSECTS'
  WHEN ABS(OFFSET_MIN_X) < 0.01 THEN 'INTERSECTS'
  WHEN ABS(OFFSET_MAX_X) < 0.01 THEN 'INTERSECTS'
  WHEN OFFSET_MIN_X > 0 THEN 'EAST'
  WHEN OFFSET_MAX_X < 0 THEN 'WEST'
  ELSE NULL 
END AS SIDE
FROM CLIPPED_OFFSET_WELLS
WHERE BOX_LENGTH <= 2500
)

-- go back and get original well mid point and slope
--nice to have for drawing boxes off of original well
, WELL_MIDS_AND_SLOPES AS (
SELECT ID
, FTP_X AS ORIGINAL_FTP_X,  FTP_Y AS ORIGINAL_FTP_Y
, LTP_X AS ORIGINAL_LTP_X,  LTP_Y AS ORIGINAL_LTP_Y
, (LTP_Y - FTP_Y)/(LTP_X - FTP_X) AS WELL_SLOPE
, -1 / WELL_SLOPE as RAY_SLOPE
FROM PERTURBED_HORIZ_OR_VERT
)

SELECT BOX.* 
, ORIGINAL_FTP_X, ORIGINAL_FTP_Y, ORIGINAL_LTP_X, ORIGINAL_LTP_Y
-- , SLOPES.MID_PT_X, SLOPES.MID_PT_Y 
, SLOPES.WELL_SLOPE, SLOPES.RAY_SLOPE
FROM BOX_LENGTH BOX
LEFT JOIN WELL_MIDS_AND_SLOPES SLOPES
ON BOX.ID = SLOPES.ID
;



